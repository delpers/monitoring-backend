from fastapi import FastAPI, APIRouter, HTTPException, Request, Depends, Header, Body, WebSocket, WebSocketDisconnect
from pydantic import BaseModel
import jwt
import datetime
import os
from dotenv import load_dotenv
from motor.motor_asyncio import AsyncIOMotorClient
from typing import Optional, List
import traceback
from bson import ObjectId, json_util
import json
import asyncio
import pytz

# Ip
from app.services.ip_public_service import get_public_ip

# Liste des connexions WebSocket actives
active_connections: List[WebSocket] = []

# Liste globale des clients connect√©s
clients: List[WebSocket] = []

# Charger les variables d'environnement
load_dotenv()
SECRET_KEY = os.getenv("SECRET_KEY")
MONGO_URI = os.getenv("MONGO_URI")

# Connexion √† MongoDB
client = AsyncIOMotorClient(MONGO_URI)
db = client.monitoring_db
visits_collection = db.visits
ip_collection = db.ip_logs  # Collection pour les logs d'IP

app = FastAPI()
router = APIRouter()

# üìå Mod√®les Pydantic
class TokenRequest(BaseModel):
    domain: str
    user_id: str  

class UserVisit(BaseModel):
    ip: str
    user_agent: str
    date_entree: datetime.datetime
    date_sortie: Optional[datetime.datetime] = None
    domain: str
    tracking_user_analytics: str  # Identifiant utilisateur unique

class VisitUpdateData(BaseModel):
    date_sortie: datetime.datetime
    domain: str

# Route pour r√©cup√©rer l'IP publique
@router.get("/agents/ip")
async def get_ip(request: Request):
    ip_data = get_public_ip(request)
    
    if "error" in ip_data:
        raise HTTPException(status_code=500, detail=ip_data["error"])
    
    return ip_data

# üì¶ Route pour g√©n√©rer un token JWT
@router.post("/agents/generate-token")
async def generate_token(request: TokenRequest):
    try:
        full_user_id = f"{request.domain}_user_{request.user_id}"
        payload = {
            "user_id": full_user_id,
            "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1)
        }
        token = jwt.encode(payload, SECRET_KEY, algorithm="HS256")
        
        if isinstance(token, bytes):
            token = token.decode('utf-8')
            
        return {"token": token}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur de g√©n√©ration du token: {str(e)}")

# üîê V√©rification du token JWT
def verify_token(authorization: str = Header(...)):
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Token manquant ou mal format√©")
    
    try:
        token = authorization.split("Bearer ")[1]
        decoded_token = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        return decoded_token
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expir√©")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Token invalide")


# Fonction pour envoyer une mise √† jour en temps r√©el √† toutes les connexions actives
async def notify_visits_change(visit_data: dict, event_type: str = "new_visit"):
    message = json.dumps({
        "event": event_type,
        "data": visit_data
    }, default=custom_json_serializer)  # Utiliser la fonction de s√©rialisation personnalis√©e
    # Envoyer le message √† toutes les connexions actives
    for connection in active_connections:
        try:
            await connection.send_text(message)
        except Exception as e:
            print(f"Erreur lors de l'envoi du message: {e}")




# Fonction pour v√©rifier les connexions WebSocket inactives
async def clean_inactive_connections():
    try:
        while True:
            active_connections[:] = [conn for conn in active_connections if conn.client_state == WebSocket.OPEN]
            await asyncio.sleep(60)
    except asyncio.CancelledError:
        print("üõë Cleaning task cancelled.")
        pass  # Ensure we handle task cancellation gracefully



# Fonction pour v√©rifier si une IP est suspecte
async def is_suspect_ip(ip: str, domain: str) -> bool:
    # R√©cup√©rer les visites r√©centes pour cette IP et domaine
    recent_visits = await visits_collection.find({
        "ip": ip,
        "domain": domain,
        "date_entree": {"$gt": datetime.datetime.utcnow() - datetime.timedelta(hours=1)}
    }).to_list(100)

    # Si l'IP a plus de 5 visites dans la derni√®re heure, elle est suspecte
    if len(recent_visits) > 5:
        return True
    return False



# Route WebSocket pour les connexions en temps r√©el
async def websocket_visits(websocket: WebSocket, token: str = Depends(verify_token)):
    try:
        await websocket.accept()
        active_connections.append(websocket)
        print(f"üîå Connexion WebSocket accept√©e. Nombre de clients connect√©s: {len(active_connections)}")
        
        # Maintenant, vous pouvez g√©rer les messages comme vous le faisiez pr√©c√©demment
        # Assurez-vous que le token est bien v√©rifi√© avant de continuer
    except Exception as e:
        print(f"Erreur de connexion WebSocket: {e}")
        await websocket.close()
        active_connections.remove(websocket)






# Fonction pour convertir automatiquement ObjectId en cha√Ænes lors de la s√©rialisation
def custom_json_serializer(obj):
    if isinstance(obj, ObjectId):
        return str(obj)  # Convertir ObjectId en cha√Æne
    if hasattr(obj, 'isoformat'):
        return obj.isoformat()  # Convertir les objets datetime en cha√Æne
    raise TypeError(f"Type {type(obj)} not serializable")







# Exemple de fonction pour d√©terminer si une IP est suspecte
async def is_suspect_ip(ip: str, domain: str) -> bool:
    # R√©cup√©rer les visites r√©centes depuis MongoDB pour cette IP
    recent_visits = await visits_collection.find({
        "ip": ip,
        "domain": domain,
        "date_entree": {"$gt": datetime.utcnow() - timedelta(hours=1)}  # Visites de la derni√®re heure
    }).to_list(100)

    # Si cette IP a d√©j√† trop de visites en peu de temps, elle est suspecte
    if len(recent_visits) > 5:
        return True

    # V√©rifier d'autres crit√®res comme les pages sensibles ou tentatives √©chou√©es
    # Par exemple : Si l'IP a tent√© de se connecter √† une page qui n'existe pas plusieurs fois
    # √Ä adapter en fonction de tes besoins

    return False




# Route pour enregistrer une nouvelle visite ou mettre √† jour une visite existante
@router.post("/agents/visit/")
async def track_visit(visit: UserVisit, token: dict = Depends(verify_token)):
    try:
        print("‚úÖ Enregistrement d'une nouvelle visite:", visit.dict())

        # V√©rifier si une visite existe d√©j√† pour cet utilisateur, sans date de sortie
        existing_visit = await visits_collection.find_one({
            "domain": visit.domain,
            "tracking_user_analytics": visit.tracking_user_analytics,
            "date_sortie": None  # Si une visite est en cours
        })

        if existing_visit:
            existing_visit_id = existing_visit['_id']
            await visits_collection.update_one(
                {"_id": existing_visit_id},
                {"$set": {"date_sortie": datetime.datetime.utcnow()}}  # Mettre √† jour la date de sortie
            )
            print(f"üîÑ La visite existante pour l'utilisateur {visit.tracking_user_analytics} a √©t√© mise √† jour avec une date de sortie.")

        # Pr√©parer les donn√©es de la nouvelle visite
        visit_data = {
            "ip": visit.ip,
            "user_agent": visit.user_agent,
            "date_entree": visit.date_entree.astimezone(datetime.timezone.utc),  # Assurer que c'est en UTC
            "date_sortie": visit.date_sortie.astimezone(datetime.timezone.utc) if visit.date_sortie else None,
            "domain": visit.domain,
            "tracking_user_analytics": visit.tracking_user_analytics
        }

        # Ins√©rer la nouvelle visite dans la collection "visits"
        result = await visits_collection.insert_one(visit_data)

        # Ajouter ou mettre √† jour l'IP dans la collection "ip_collection"
        ip_data = {
            "ip": visit.ip,
            "user_agent": visit.user_agent,
            "date_entree": visit.date_entree,
            "date_sortie": visit.date_sortie,
            "tracking_user_analytics": visit.tracking_user_analytics
        }

        await ip_collection.update_one(
            {"domain": visit.domain},  # Recherche par domaine
            {"$push": {"ips": ip_data}},  # Ajouter la nouvelle IP sous le domaine
            upsert=True  # Cr√©e une entr√©e si le domaine n'existe pas
        )

        # Notifier du changement de visite (ex: via WebSocket ou autre m√©canisme)
        await notify_visits_change(visit_data)

        return {
            "status": "success",
            "visit_id": str(result.inserted_id),
            "tracking_user_analytics": visit.tracking_user_analytics
        }
    except Exception as e:
        error_details = traceback.format_exc()
        print("‚ùå Erreur lors de l'enregistrement de la visite:", error_details)
        raise HTTPException(status_code=500, detail=f"Erreur lors de l'insertion: {str(e)}")


    

# Mise √† jour de la sortie de la visite
@router.put("/agents/visit/update/")
async def update_visit_exit(
    visit_id: str,
    visit_update: VisitUpdateData = Body(...),
    token: dict = Depends(verify_token)
):
    try:
        print("üì° Mise √† jour d'une visite avec visit_id:", visit_id)
        print("üì° Donn√©es re√ßues:", visit_update.dict())

        try:
            object_id = ObjectId(visit_id)  # Convertir l'ID de la visite en ObjectId
        except Exception as e:
            raise HTTPException(status_code=400, detail="ID de visite invalide")

        existing_visit = await visits_collection.find_one({"_id": object_id})
        if not existing_visit:
            raise HTTPException(status_code=404, detail="Visite introuvable")

        update_data = {}

        if hasattr(visit_update, 'date_sortie') and visit_update.date_sortie is not None:
            if visit_update.date_sortie.tzinfo is None:
                visit_update.date_sortie = visit_update.date_sortie.replace(tzinfo=datetime.timezone.utc)
            update_data["date_sortie"] = visit_update.date_sortie
        else:
            update_data["date_sortie"] = None
            update_data["date_entree"] = datetime.datetime.utcnow()

        update_result = await visits_collection.update_one(
            {"_id": object_id},
            {"$set": update_data}
        )

        if update_result.modified_count == 0:
            raise HTTPException(status_code=400, detail="Mise √† jour impossible")

        updated_visit = await visits_collection.find_one({"_id": object_id})
        if not updated_visit:
            raise HTTPException(status_code=404, detail="Visite introuvable apr√®s mise √† jour")

        event_type = "update_exit" if "date_sortie" in update_data and update_data["date_sortie"] is not None else "update_session"
        await notify_visits_change(updated_visit, event_type)

        # Retourner les r√©sultats apr√®s conversion de l'ObjectId en cha√Æne
        return {
            "status": "success", 
            "message": "Session mise √† jour",
            "visit_id": str(object_id),
            "updated_visit": json.dumps(updated_visit, default=custom_json_serializer)  # S√©rialisation personnalis√©e
        }

    except Exception as e:
        error_details = traceback.format_exc()
        print(f"‚ùå Erreur lors de la mise √† jour: {error_details}")
        raise HTTPException(status_code=500, detail=f"Erreur lors de la mise √† jour: {str(e)}")


@router.get("/agents/visits")
async def get_visits_and_ips():
    try:
        print("üì• Tentative de r√©cup√©ration des visites...")
        visits = await visits_collection.find().to_list(100)
        print(f"üîç Visites r√©cup√©r√©es: {visits}")

        if not visits:
            print("üì≠ Aucune visite trouv√©e.")
            return {"status": "success", "visits": [], "ips": []}

        for visit in visits:
            visit["_id"] = str(visit["_id"])

        print("üì• Tentative de r√©cup√©ration des IPs...")
        ip_logs = await ip_collection.find().to_list(100)
        print(f"üîç IPs r√©cup√©r√©es: {ip_logs}")

        for ip_log in ip_logs:
            ip_log["_id"] = str(ip_log["_id"])

        return {
            "status": "success",
            "visits": visits,
            "ips": ip_logs
        }

    except Exception as e:
        error_details = traceback.format_exc()
        print(f"‚ùå Erreur lors de la r√©cup√©ration des visites et IPs: {error_details}")
        raise HTTPException(status_code=500, detail=f"Erreur lors de la r√©cup√©ration des visites et IPs: {str(e)}")


# Route WebSocket pour les connexions en temps r√©el
@router.websocket("/ws/visits")
async def websocket_visits(websocket: WebSocket):
    try:
        await websocket.accept()
        active_connections.append(websocket)  # Ajouter le client √† la liste des connexions actives
        print("üîå Connexion WebSocket accept√©e")
        print(f"üåê Nombre de clients connect√©s : {len(active_connections)}")
        
        while True:
            # Recevoir les messages du client
            data = await websocket.receive_text()
            print(f"üì® Message brut re√ßu: {data}")

            try:
                # On suppose que les messages sont en JSON
                message = json.loads(data)
                
                if message.get("event") == "new_visit":
                    print("Nouvelle visite re√ßue", message)
                    # Diffuser la nouvelle visite √† tous les clients
                    await notify_visits_change(message['data'], event_type="new_visit")
                
                elif message.get("event") == "update_exit":
                    print("Mise √† jour de sortie re√ßue", message)
                    # Diffuser la mise √† jour de sortie √† tous les clients
                    await notify_visits_change(message['data'], event_type="update_exit")
                
                else:
                    print("√âv√©nement inconnu")
            except json.JSONDecodeError:
                print("Erreur de d√©codage JSON re√ßu")
                await websocket.send_text("Erreur: message malform√©")

    except WebSocketDisconnect:
        # Supprimer la connexion de la liste active lorsqu'un client se d√©connecte
        active_connections.remove(websocket)
        print("‚ùå Un client s'est d√©connect√©.")
        print(f"üåê Nombre de clients restants : {len(active_connections)}")

    except Exception as e:
        print(f"‚ùó Erreur WebSocket: {e}")
        await websocket.send_text(f"Erreur serveur: {str(e)}")



# Ajouter la t√¢che de nettoyage lors du d√©marrage du serveur
@app.on_event("shutdown")
async def shutdown_event():
    # Close all active WebSocket connections
    for connection in active_connections:
        await connection.close()
    active_connections.clear()
    print("üåê All WebSocket connections closed.")